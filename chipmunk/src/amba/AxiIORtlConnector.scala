package chipmunk
package amba

import chisel3._
import chisel3.experimental.dataview.DataView

/** Generate a [[Axi4IO]] or [[Axi3IO]] interface with blackbox-friendly port names.
  *
  * In many AXI implementations generated by 3rd-party tools (such as ARM NIC or AMD Vivado), the ports are named in the
  * form "AWADDR" or "AWADDR_some_postfix", however Chisel users prefer to use hierarchical Bundles (that is,
  * [[Axi4IO]]/[[Axi3IO]]). However, the latter will generate signal naming similar to "aw_bits_addr", which is
  * difficult to align with blackbox's RTL. You can use this class instead of [[Axi4IO]]/[[Axi3IO]] if you need
  * flattened port naming (such as when creating a Blackbox from a external RTL file).
  *
  * @note
  *   This class only supports optional name suffixes. Prefixes can be implemented naturally through signal naming. If
  *   you don't need the prefix part of the port names, consider using [[FlatIO]] instead of [[IO]].
  *
  * @example
  *   {{{
  * val s = FlatIO(Slave(new Axi4IORtlConnector(..., postfix = Some("abc"))))
  * val m = IO(Master(new Axi4IO(...)))
  * val sView = s0.viewAs[Axi4IO]
  * m <> sView
  *   }}}
  *
  * @param dataWidth
  *   The bit width of the [[Axi4IO]]/[[Axi3IO]] bus data.
  * @param addrWidth
  *   The bit width of the [[Axi4IO]]/[[Axi3IO]] bus address.
  * @param idWidth
  *   The bit width of the [[Axi4IO]]/[[Axi3IO]] bus id.
  * @param hasQos
  *   Whether the bus has QoS signals. Default is false.
  * @param hasRegion
  *   Whether the bus has region signals. Default is false.
  * @param postfix
  *   The postfix of the port names. If it is set, the port names will be appended with the postfix (e.g., AWADDR ->
  *   AWADDR_abc). Leave it None if you don't need it.
  * @param toggleCase
  *   Whether to toggle the case of the port names (e.g., AWADDR -> awaddr_abc). Default is false.
  * @param axi3
  *   Whether the bus is AXI3. Default is false (i.e., AXI4).
  */
private[amba] class AxiIORtlConnector(
  val dataWidth: Int,
  val addrWidth: Int,
  val idWidth: Int,
  val hasQos: Boolean = false,
  val hasRegion: Boolean = false,
  postfix: Option[String] = None,
  toggleCase: Boolean = false,
  axi3: Boolean = false
) extends RtlConnector(postfix, toggleCase)({
      val strobeWidth: Int = dataWidth / 8
      val lockWidth: Int   = if (axi3) 2 else 1
      val lenWidth: Int    = if (axi3) 4 else 8
      val axiPorts = Seq(
        "AWID"     -> (if (idWidth != 0) Some(Output(UInt(idWidth.W))) else None),
        "AWADDR"   -> Output(UInt(addrWidth.W)),
        "AWLEN"    -> Output(UInt(lenWidth.W)),
        "AWSIZE"   -> Output(AxiBurstSize()),
        "AWBURST"  -> Output(AxiBurstType()),
        "AWLOCK"   -> Output(UInt(lockWidth.W)),
        "AWCACHE"  -> Output(UInt(4.W)),
        "AWPROT"   -> Output(UInt(3.W)),
        "AWQOS"    -> (if (hasQos) Some(Output(UInt(4.W))) else None),
        "AWREGION" -> (if (hasRegion) Some(Output(UInt(4.W))) else None),
        "AWVALID"  -> Output(Bool()),
        "AWREADY"  -> Input(Bool()),
        "WID"      -> (if (idWidth != 0 && axi3) Some(Output(UInt(idWidth.W))) else None),
        "WDATA"    -> Output(UInt(dataWidth.W)),
        "WSTRB"    -> Output(UInt(strobeWidth.W)),
        "WLAST"    -> Output(Bool()),
        "WVALID"   -> Output(Bool()),
        "WREADY"   -> Input(Bool()),
        "BID"      -> (if (idWidth != 0) Some(Input(UInt(idWidth.W))) else None),
        "BRESP"    -> Input(AxiResp()),
        "BVALID"   -> Input(Bool()),
        "BREADY"   -> Output(Bool()),
        "ARID"     -> (if (idWidth != 0) Some(Output(UInt(idWidth.W))) else None),
        "ARADDR"   -> Output(UInt(addrWidth.W)),
        "ARLEN"    -> Output(UInt(lenWidth.W)),
        "ARSIZE"   -> Output(AxiBurstSize()),
        "ARBURST"  -> Output(AxiBurstType()),
        "ARLOCK"   -> Output(UInt(lockWidth.W)),
        "ARCACHE"  -> Output(UInt(4.W)),
        "ARPROT"   -> Output(UInt(3.W)),
        "ARQOS"    -> (if (hasQos) Some(Output(UInt(4.W))) else None),
        "ARREGION" -> (if (hasRegion) Some(Output(UInt(4.W))) else None),
        "ARVALID"  -> Output(Bool()),
        "ARREADY"  -> Input(Bool()),
        "RID"      -> (if (idWidth != 0) Some(Input(UInt(idWidth.W))) else None),
        "RDATA"    -> Input(UInt(dataWidth.W)),
        "RRESP"    -> Input(AxiResp()),
        "RLAST"    -> Input(Bool()),
        "RVALID"   -> Input(Bool()),
        "RREADY"   -> Output(Bool())
      ).collect {
        case (key, Some(value: Data)) => key -> value
        case (key, value: Data)       => key -> value
      }
      axiPorts
    }: _*)
    with IsMasterSlave {
  if (axi3) {
    require(!hasQos, "AXI3 does not support QoS signals.")
    require(!hasRegion, "AXI3 does not support region signals.")
  }

  override def isMaster = true
}

object AxiIORtlConnector {
  private def mapPortsToRtlConnector(rc: AxiIORtlConnector, b: AxiIOBase) = {
    var portPairs = Seq(
      rc("AWADDR")  -> b.aw.bits.addr,
      rc("AWLEN")   -> b.aw.bits.len,
      rc("AWSIZE")  -> b.aw.bits.size,
      rc("AWBURST") -> b.aw.bits.burst,
      rc("AWLOCK")  -> b.aw.bits.lock,
      rc("AWCACHE") -> b.aw.bits.cache,
      rc("AWPROT")  -> b.aw.bits.prot,
      rc("AWVALID") -> b.aw.valid,
      rc("AWREADY") -> b.aw.ready,
      rc("WDATA")   -> b.w.bits.data,
      rc("WSTRB")   -> b.w.bits.strb,
      rc("WLAST")   -> b.w.bits.last,
      rc("WVALID")  -> b.w.valid,
      rc("WREADY")  -> b.w.ready,
      rc("BRESP")   -> b.b.bits.resp,
      rc("BVALID")  -> b.b.valid,
      rc("BREADY")  -> b.b.ready,
      rc("ARADDR")  -> b.ar.bits.addr,
      rc("ARLEN")   -> b.ar.bits.len,
      rc("ARSIZE")  -> b.ar.bits.size,
      rc("ARBURST") -> b.ar.bits.burst,
      rc("ARLOCK")  -> b.ar.bits.lock,
      rc("ARCACHE") -> b.ar.bits.cache,
      rc("ARPROT")  -> b.ar.bits.prot,
      rc("ARVALID") -> b.ar.valid,
      rc("ARREADY") -> b.ar.ready,
      rc("RDATA")   -> b.r.bits.data,
      rc("RRESP")   -> b.r.bits.resp,
      rc("RLAST")   -> b.r.bits.last,
      rc("RVALID")  -> b.r.valid,
      rc("RREADY")  -> b.r.ready
    )
    if (rc.hasRegion) {
      portPairs ++= Seq(rc("AWREGION") -> b.aw.bits.region.get, rc("ARREGION") -> b.ar.bits.region.get)
    }
    if (rc.hasQos) {
      portPairs ++= Seq(rc("AWQOS") -> b.aw.bits.qos.get, rc("ARQOS") -> b.ar.bits.qos.get)
    }
    if (rc.idWidth != 0) {
      portPairs ++= Seq(
        rc("AWID") -> b.aw.bits.id.get,
        rc("BID")  -> b.b.bits.id.get,
        rc("ARID") -> b.ar.bits.id.get,
        rc("RID")  -> b.r.bits.id.get
      )
      if (b.w.bits.id.isDefined) { // AXI3
        portPairs ++= Seq(rc("WID") -> b.w.bits.id.get)
      }
    }
    portPairs
  }

  implicit val axi4View: DataView[Axi4IORtlConnector, Axi4IO] = DataView.mapping(
    rc => new Axi4IO(rc.dataWidth, rc.addrWidth, rc.idWidth, rc.hasQos, rc.hasRegion),
    (rc, b) => mapPortsToRtlConnector(rc, b)
  )

  implicit val axi3View: DataView[Axi3IORtlConnector, Axi3IO] =
    DataView.mapping(rc => new Axi3IO(rc.dataWidth, rc.addrWidth, rc.idWidth), (rc, b) => mapPortsToRtlConnector(rc, b))
}

/** Generate a [[Axi4IO]] interface with blackbox-friendly port names.
  *
  * @example
  *   {{{
  * val s = FlatIO(Slave(new Axi4IORtlConnector(..., postfix = Some("abc"))))
  * val m = IO(Master(new Axi4IO(...)))
  * val sView = s0.viewAs[Axi4IO]
  * m <> sView
  *   }}}
  *
  * @param dataWidth
  *   The bit width of the [[Axi4IO]] bus data.
  * @param addrWidth
  *   The bit width of the [[Axi4IO]] bus address.
  * @param idWidth
  *   The bit width of the [[Axi4IO]] bus id.
  * @param hasQos
  *   Whether the bus has QoS signals. Default is false.
  * @param hasRegion
  *   Whether the bus has region signals. Default is false.
  * @param postfix
  *   The postfix of the port names. If it is set, the port names will be appended with the postfix (e.g., AWADDR ->
  *   AWADDR_abc). Leave it None if you don't need it.
  * @param toggleCase
  *   Whether to toggle the case of the port names (e.g., AWADDR -> awaddr_abc). Default is false.
  *
  * @see
  *   [[AxiIORtlConnector]]
  */
class Axi4IORtlConnector(
  dataWidth: Int,
  addrWidth: Int,
  idWidth: Int,
  hasQos: Boolean = false,
  hasRegion: Boolean = false,
  postfix: Option[String] = None,
  toggleCase: Boolean = false
) extends AxiIORtlConnector(dataWidth, addrWidth, idWidth, hasQos, hasRegion, postfix)

/** Generate a [[Axi3IO]] interface with blackbox-friendly port names.
  *
  * @example
  *   {{{
  * val s = FlatIO(Slave(new Axi3IORtlConnector(..., postfix = Some("abc"))))
  * val m = IO(Master(new Axi3IO(...)))
  * val sView = s0.viewAs[Axi3IO]
  * m <> sView
  *   }}}
  *
  * @param dataWidth
  *   The bit width of the [[Axi3IO]] bus data.
  * @param addrWidth
  *   The bit width of the [[Axi3IO]] bus address.
  * @param idWidth
  *   The bit width of the [[Axi3IO]] bus id.
  * @param postfix
  *   The postfix of the port names. If it is set, the port names will be appended with the postfix (e.g., AWADDR ->
  *   AWADDR_abc). Leave it None if you don't need it.
  * @param toggleCase
  *   Whether to toggle the case of the port names (e.g., AWADDR -> awaddr_abc). Default is false.
  *
  * @see
  *   [[AxiIORtlConnector]]
  */
class Axi3IORtlConnector(
  dataWidth: Int,
  addrWidth: Int,
  idWidth: Int,
  postfix: Option[String] = None,
  toggleCase: Boolean = false
) extends AxiIORtlConnector(dataWidth, addrWidth, idWidth, postfix = postfix, axi3 = true)
